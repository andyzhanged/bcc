#! /usr/bin/python2
#
# memleak   Trace and display outstanding allocations to detect
#           cuda memory leaks in user-mode processes.
#
# USAGE: memleak [-h] [-p PID] [-t] [-a] [-o OLDER] [-c COMMAND]
#                [--combined-only] [-s SAMPLE_RATE] [-T TOP] [-z MIN_SIZE]
#                [-Z MAX_SIZE] [-O OBJ]
#                [interval] [count]
#
# Licensed under the Apache License, Version 2.0 (the "License")

from bcc import BPF
from time import sleep
from datetime import datetime
import resource
import argparse
import subprocess
import os

class Allocation(object):
        def __init__(self, stack, size):
                self.stack = stack
                self.count = 1
                self.size = size

        def update(self, size):
                self.count += 1
                self.size += size

def run_command_get_output(command):
        p = subprocess.Popen(command.split(),
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        return iter(p.stdout.readline, b'')

def run_command_get_pid(command):
        p = subprocess.Popen(command.split())
        return p.pid

def get_proc_status(pid):
        for line in open("/proc/%d/status" % pid).readlines():
                if line.startswith("State:"):
                        return line.split(":",1)[1].strip().split(' ')[0]
        return None

def is_proc_exit(pid):
        status = get_proc_status(pid)
        if status is None or status == "Z":
                return True
        return False

examples = """
EXAMPLES:

./memleak -p $(pidof cuda_app)
        Trace allocations and display a summary of "leaked" (outstanding)
        allocations every 5 seconds
./memleak -p $(pidof cuda_app) -t
        Trace allocations and display each individual allocator function call
./memleak -ap $(pidof cuda_app) 10
        Trace allocations and display allocated addresses, sizes, and stacks
        every 10 seconds for outstanding allocations
./memleak -c "./cuda_app"
        Run the specified command and trace its allocations
./memleak
        Trace allocations in cuda display a summary of outstanding
        allocations every 5 seconds
./memleak -o 60000
        Trace allocations in kernel mode and display a summary of outstanding
        allocations that are at least one minute (60 seconds) old
./memleak -s 5
        Trace roughly every 5th allocation, to reduce overhead
"""

description = """
Trace outstanding cuda memory allocations that weren't freed.
Supports trace cudaMalloc cudaFree by now.
"""

parser = argparse.ArgumentParser(description=description,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=examples)
parser.add_argument("-p", "--pid", type=int, default=-1,
        help="the PID to trace")
parser.add_argument("-t", "--trace", action="store_true",
        help="print trace messages for each alloc/free call")
parser.add_argument("interval", nargs="?", default=5, type=int,
        help="interval in seconds to print outstanding allocations")
parser.add_argument("count", nargs="?", type=int,
        help="number of times to print the report before exiting")
parser.add_argument("-a", "--show-allocs", default=False, action="store_true",
        help="show allocation addresses and sizes as well as call stacks")
parser.add_argument("-o", "--older", default=500, type=int,
        help="prune allocations younger than this age in milliseconds")
parser.add_argument("-c", "--command",
        help="execute and trace the specified command")
parser.add_argument("--combined-only", default=False, action="store_true",
        help="show combined allocation statistics only")
parser.add_argument("-s", "--sample-rate", default=1, type=int,
        help="sample every N-th allocation to decrease the overhead")
parser.add_argument("-T", "--top", type=int, default=10,
        help="display only this many top allocating stacks (by size)")
parser.add_argument("-z", "--min-size", type=int,
        help="capture only allocations larger than this size")
parser.add_argument("-Z", "--max-size", type=int,
        help="capture only allocations smaller than this size")
parser.add_argument("-O", "--obj", type=str, default="/usr/local/corex/lib64/libcudart.so",
        help="attach to allocator functions in the specified object, default is /usr/local/corex/lib64/libcudart.so")

args = parser.parse_args()

pid = args.pid
command = args.command
interval = args.interval
min_age_ns = 1e6 * args.older
sample_every_n = args.sample_rate
num_prints = args.count
top_stacks = args.top
min_size = args.min_size
max_size = args.max_size
obj = args.obj

if min_size is not None and max_size is not None and min_size > max_size:
        print("min_size (-z) can't be greater than max_size (-Z)")
        exit(1)

if command is not None:
        print("Executing '%s' and tracing the resulting process." % command)
        pid = run_command_get_pid(command)


bpf_source = """
#include <uapi/linux/ptrace.h>

struct alloc_info_t {
        u64 size;
        u64 timestamp_ns;
        int stack_id;
};

struct combined_alloc_info_t {
        u64 total_size;
        u64 number_of_allocs;
};

BPF_HASH(sizes, u64);
BPF_HASH(cudaMallocPara1, u64);
BPF_TABLE("hash", u64, struct alloc_info_t, allocs, 1000000);
BPF_STACK_TRACE(stack_traces, 10240)
BPF_TABLE("hash", u64, struct combined_alloc_info_t, combined_allocs, 10240);

static inline void update_statistics_add(u64 stack_id, u64 sz) {
        struct combined_alloc_info_t *existing_cinfo;
        struct combined_alloc_info_t cinfo = {0};

        existing_cinfo = combined_allocs.lookup(&stack_id);
        if (existing_cinfo != 0)
                cinfo = *existing_cinfo;

        cinfo.total_size += sz;
        cinfo.number_of_allocs += 1;

        combined_allocs.update(&stack_id, &cinfo);
}

static inline void update_statistics_del(u64 stack_id, u64 sz) {
        struct combined_alloc_info_t *existing_cinfo;
        struct combined_alloc_info_t cinfo = {0};

        existing_cinfo = combined_allocs.lookup(&stack_id);
        if (existing_cinfo != 0)
                cinfo = *existing_cinfo;

        if (sz >= cinfo.total_size)
                cinfo.total_size = 0;
        else
                cinfo.total_size -= sz;

        if (cinfo.number_of_allocs > 0)
                cinfo.number_of_allocs -= 1;

        combined_allocs.update(&stack_id, &cinfo);
}

static inline int gen_alloc_enter(struct pt_regs *ctx) {
        SIZE_FILTER
        if (SAMPLE_EVERY_N > 1) {
                u64 ts = bpf_ktime_get_ns();
                if (ts % SAMPLE_EVERY_N != 0)
                        return 0;
        }

	u64 pid_tgid = bpf_get_current_pid_tgid();
        u64 cpu_ptr = PT_REGS_PARM1(ctx);
        u64 size = PT_REGS_PARM2(ctx);
        sizes.update(&pid_tgid, &size);
	cudaMallocPara1.update(&pid_tgid, &cpu_ptr);

        if (SHOULD_PRINT)
                bpf_trace_printk("alloc entered, size = %u, cpu_ptr %lx\\n", size, cpu_ptr);
        return 0;
}

static inline int gen_alloc_exit2(struct pt_regs *ctx) {
        struct alloc_info_t info = {0};
        u64 pid_tgid = bpf_get_current_pid_tgid();
        u64* size = sizes.lookup(&pid_tgid);
        u64 dev_ptr;

        if (PT_REGS_RC(ctx) != 0) /*cudaMalloc failed*/
                return 0;

        if (size == 0)
                return 0; // missed alloc entry
        info.size = *size;

	u64 *cpu_ptr_temp = cudaMallocPara1.lookup(&pid_tgid);
        if (cpu_ptr_temp == 0) {
                sizes.delete(&pid_tgid);
                return 0;
        }
        void *cpu_ptr = (void *)*cpu_ptr_temp;
        if(bpf_probe_read(&dev_ptr, sizeof(u64), cpu_ptr)){
                bpf_trace_printk("read cudaMalloc return addr failed from ptr is 0x%lx", cpu_ptr);
                return 0;
        }

        cudaMallocPara1.delete(&pid_tgid);
        info.timestamp_ns = bpf_ktime_get_ns();
        info.stack_id = stack_traces.get_stackid(ctx, STACK_FLAGS);
        allocs.update(&dev_ptr, &info);
        update_statistics_add(info.stack_id, info.size);

        if (SHOULD_PRINT) {
                bpf_trace_printk("cudaMalloc exited, size = %lu, result = %lx\\n",
                                info.size, dev_ptr);
        }

        return 0;
}

static inline int gen_alloc_exit(struct pt_regs *ctx) {
        return gen_alloc_exit2(ctx);
}

static inline int gen_free_enter(struct pt_regs *ctx, void *address) {
        u64 addr = (u64)address;
        struct alloc_info_t *info = allocs.lookup(&addr);

        if (info == 0)
                return 0;

        allocs.delete(&addr);
        update_statistics_del(info->stack_id, info->size);

        if (SHOULD_PRINT) {
                bpf_trace_printk("free entered, address = %lx, size = %lu\\n",
                                address, info->size);
        }
        return 0;
}

int cudaMalloc_enter(struct pt_regs *ctx, size_t size) {
        return gen_alloc_enter(ctx);
}

int cudaMalloc_exit(struct pt_regs *ctx) {
        return gen_alloc_exit(ctx);
}

int cudaFree_enter(struct pt_regs *ctx, void *address) {
        return gen_free_enter(ctx, address);
}
"""

bpf_source = bpf_source.replace("SHOULD_PRINT", "1")
bpf_source = bpf_source.replace("SAMPLE_EVERY_N", str(sample_every_n))
bpf_source = bpf_source.replace("PAGE_SIZE", str(resource.getpagesize()))

size_filter = ""
if min_size is not None and max_size is not None:
        size_filter = "if (size < %d || size > %d) return 0;" % \
                        (min_size, max_size)
elif min_size is not None:
        size_filter = "if (size < %d) return 0;" % min_size
elif max_size is not None:
        size_filter = "if (size > %d) return 0;" % max_size

bpf_source = bpf_source.replace("SIZE_FILTER", size_filter)

stack_flags = "BPF_F_REUSE_STACKID|BPF_F_USER_STACK"
bpf_source = bpf_source.replace("STACK_FLAGS", stack_flags)

bpf = BPF(text=bpf_source)
if obj is None:
        obj = "/usr/local/corex/lib64/libcudart.so"
if not os.path.exists(obj):
        print("cuda library %s not exist\n" % obj)
        exit()

print("Attaching to pid %d, Ctrl+C to quit." % pid)

def attach_probes(sym, fn_prefix=None, can_fail=False):
        if fn_prefix is None:
                fn_prefix = sym

        try:
                bpf.attach_uprobe(name=obj, sym=sym,
                                        fn_name=fn_prefix + "_enter",
                                        pid=pid)
                bpf.attach_uretprobe(name=obj, sym=sym,
                                        fn_name=fn_prefix + "_exit",
                                        pid=pid)
        except Exception:
                if can_fail:
                        return
                else:
                        raise

attach_probes("cudaMalloc")
bpf.attach_uprobe(name=obj, sym="cudaFree", fn_name="cudaFree_enter",
                                pid=pid)

def print_outstanding():
        print("[%s] Top %d stacks with outstanding allocations:" %
                (datetime.now().strftime("%H:%M:%S"), top_stacks))
        alloc_info = {}
        allocs = bpf["allocs"]
        stack_traces = bpf["stack_traces"]
        for address, info in sorted(allocs.items(), key=lambda a: a[1].size):
                if BPF.monotonic_time() - min_age_ns < info.timestamp_ns:
                        continue
                if info.stack_id < 0:
                        continue
                if info.stack_id in alloc_info:
                        alloc_info[info.stack_id].update(info.size)
                else:
                        stack = list(stack_traces.walk(info.stack_id))
                        combined = []
                        for addr in stack:
                                combined.append(bpf.sym(addr, pid,
                                        show_module=True, show_offset=True))
                        alloc_info[info.stack_id] = Allocation(combined, info.size)
                if args.show_allocs:
                        print("\taddr = %x size = %s" %(address.value, info.size))
        to_show = sorted(alloc_info.values(), key=lambda a: a.size)[-top_stacks:]
        for alloc in to_show:
                print("\t%d bytes in %d allocations from stack\n\t\t%s" %
                        (alloc.size, alloc.count, "\n\t\t".join(alloc.stack)))

def print_outstanding_combined():
        stack_traces = bpf["stack_traces"]
        stacks = sorted(bpf["combined_allocs"].items(),
                        key=lambda a: -a[1].total_size)
        cnt = 1
        entries = []
        for stack_id, info in stacks:
                try:
                        trace = []
                        for addr in stack_traces.walk(stack_id.value):
                                sym = bpf.sym(addr, pid,
                                                show_module=True,
                                                show_offset=True)
                                trace.append(sym)
                        trace = "\n\t\t".join(trace)
                except KeyError:
                        trace = "stack information lost"

                entry = ("\t%d bytes in %d allocations from stack\n\t\t%s" %
                        (info.total_size, info.number_of_allocs, trace))
                entries.append(entry)

                cnt += 1
                if cnt > top_stacks:
                        break

        print("[%s] Top %d stacks with outstanding allocations:" %
                (datetime.now().strftime("%H:%M:%S"), top_stacks))
        print('\n'.join(reversed(entries)))

count_so_far = 0

while True:
        try:
                sleep(interval)
        except KeyboardInterrupt:
                exit()

        proc_exit = is_proc_exit(pid)
        if proc_exit is True:
                print("Traced process exited, check stack above\n")
                exit()

        if args.combined_only:
                print_outstanding_combined()
        else:
                print_outstanding()

        count_so_far += 1
        if num_prints is not None and count_so_far >= num_prints:
                exit()
